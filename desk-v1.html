<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escritorio Industrial 3D - Setup Final</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: system-ui, sans-serif; }

        #controls-ui {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            pointer-events: none;
            z-index: 20;
            max-height: 90vh;
            overflow-y: auto;
        }

        .control-box {
            background: rgba(255, 255, 255, 0.85);
            pointer-events: auto;
            min-width: 160px;
        }

        summary {
            padding: 6px 8px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            color: #333;
            list-style: none;
            outline: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        summary::-webkit-details-marker { display: none; }
        summary::after { content: '▾'; font-size: 9px; opacity: 0.5; }
        details[open] summary::after { content: '▴'; }

        .content { padding: 4px 8px 8px; }

        .row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
            font-size: 10px;
            color: #444;
        }
        .row:last-child { margin-bottom: 0; }
        .row input[type="checkbox"] { cursor: pointer; width: 14px; height: 14px; margin: 0; }
        .row select {
            flex: 1;
            padding: 3px 4px;
            font-size: 10px;
            border: none;
            background: rgba(0,0,0,0.05);
            outline: none;
            cursor: pointer;
        }
        .row label { font-size: 10px; color: #555; flex-shrink: 0; }

    </style>
</head>
<body>
    <div id="controls-ui">
        <details class="control-box">
            <summary>Vista</summary>
            <div class="content">
                <div class="row"><input type="checkbox" id="check-surface" checked onchange="toggleSurface()"><label>Tapas</label></div>
                <div class="row"><input type="checkbox" id="check-dims" onchange="toggleDimensions()"><label>Medidas</label></div>
            </div>
        </details>

        <details class="control-box">
            <summary>Accesorios</summary>
            <div class="content">
                <div class="row"><input type="checkbox" id="check-chair" onchange="updateItems()"><label>Silla</label></div>
                <div class="row"><input type="checkbox" id="check-laptop" onchange="updateItems()"><label>Laptop</label></div>
                <div class="row"><input type="checkbox" id="check-monitor" onchange="updateItems()"><label>Monitor base</label></div>
                <div class="row"><input type="checkbox" id="check-arm-monitor" onchange="updateItems()"><label>Monitor brazo</label></div>
                <div class="row"><input type="checkbox" id="check-lamp" onchange="updateItems()"><label>Lámpara</label></div>
            </div>
        </details>

        <details class="control-box" open>
            <summary>Faldones</summary>
            <div class="content">
                <div class="row">
                    <label>Frontal</label>
                    <select id="hFrontSelector" onchange="updateSkirts()">
                        <option value="0">0cm</option>
                        <option value="5">5cm</option>
                        <option value="10">10cm</option>
                        <option value="15" selected>15cm</option>
                        <option value="20">20cm</option>
                        <option value="25">25cm</option>
                    </select>
                </div>
                <div class="row">
                    <label>Trasero</label>
                    <select id="hBackSelector" onchange="updateSkirts()">
                        <option value="20">20cm</option>
                        <option value="25">25cm</option>
                        <option value="30" selected>30cm</option>
                        <option value="35">35cm</option>
                        <option value="40">40cm</option>
                    </select>
                </div>
            </div>
        </details>

        <details class="control-box">
            <summary>Acabado</summary>
            <div class="content">
                <div class="row">
                    <label>Principal</label>
                    <select id="userWoodSelector" onchange="changeWood('user', this.value)">
                        <option value="negro">Negro</option>
                        <option value="wengue">Wengue</option>
                        <option value="roble_oscuro">Roble Oscuro</option>
                        <option value="roble_milano">Roble Milano</option>
                        <option value="nogal_amazonico">Nogal Amazónico</option>
                        <option value="nogal_africano">Nogal Africano</option>
                        <option value="cerezo">Cerezo</option>
                        <option value="maple">Maple</option>
                        <option value="haya_natural">Haya Natural</option>
                        <option value="cacao">Cacao</option>
                        <option value="blanco">Blanco</option>
                        <option value="gris">Gris</option>
                        <option value="gris_grafito">Gris Grafito</option>
                        <option value="roble_antracita">Roble Antracita</option>
                        <option value="verde_oliva">Verde Oliva</option>
                        <option value="azul_acero">Azul Acero</option>
                        <option value="rojo_colonial">Rojo Colonial</option>
                    </select>
                </div>
                <div class="row">
                    <label>Posterior</label>
                    <select id="backWoodSelector" onchange="changeWood('back', this.value)">
                        <option value="negro">Negro</option>
                        <option value="wengue">Wengue</option>
                        <option value="roble_oscuro">Roble Oscuro</option>
                        <option value="roble_milano">Roble Milano</option>
                        <option value="nogal_amazonico">Nogal Amazónico</option>
                        <option value="nogal_africano">Nogal Africano</option>
                        <option value="cerezo">Cerezo</option>
                        <option value="maple">Maple</option>
                        <option value="haya_natural">Haya Natural</option>
                        <option value="cacao">Cacao</option>
                        <option value="blanco">Blanco</option>
                        <option value="gris">Gris</option>
                        <option value="gris_grafito">Gris Grafito</option>
                        <option value="roble_antracita">Roble Antracita</option>
                        <option value="verde_oliva">Verde Oliva</option>
                        <option value="azul_acero">Azul Acero</option>
                        <option value="rojo_colonial">Rojo Colonial</option>
                    </select>
                </div>
            </div>
        </details>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(-250, 180, -250);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI - 0.1;

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(-80, 200, -80);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        dirLight.shadow.camera.far = 1000;
        scene.add(dirLight);

        const woodMaterials = {
            negro: { color: 0x1a1a1a, roughness: 0.9 },
            wengue: { color: 0x3d2b1f, roughness: 0.8 },
            roble_oscuro: { color: 0x4a3728, roughness: 0.7 },
            roble_milano: { color: 0x8b5a2b, roughness: 0.6 },
            nogal_amazonico: { color: 0x5d4037, roughness: 0.7 },
            nogal_africano: { color: 0x4e3524, roughness: 0.7 },
            cerezo: { color: 0x8b4513, roughness: 0.6 },
            maple: { color: 0xdeb887, roughness: 0.5 },
            haya_natural: { color: 0xe8dcc8, roughness: 0.5 },
            cacao: { color: 0x3e2723, roughness: 0.8 },
            blanco: { color: 0xf5f5f5, roughness: 0.4 },
            gris: { color: 0x9e9e9e, roughness: 0.6 },
            gris_grafito: { color: 0x424242, roughness: 0.7 },
            roble_antracita: { color: 0x2e2e2e, roughness: 0.8 },
            verde_oliva: { color: 0x6b8e23, roughness: 0.5 },
            azul_acero: { color: 0x37474f, roughness: 0.6 },
            rojo_colonial: { color: 0x8b0000, roughness: 0.6 }
        };

        const userWoodMaterial = new THREE.MeshStandardMaterial({ color: woodMaterials.negro.color, roughness: 0.9, side: THREE.DoubleSide });
        const backWoodMaterial = new THREE.MeshStandardMaterial({ color: woodMaterials.negro.color, roughness: 0.9, side: THREE.DoubleSide });
        const metalBlackMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.5, metalness: 0.7 });
        const silverMaterial = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.3, metalness: 0.8 });
        const leatherMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
        const trayMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.5, metalness: 0.6, side: THREE.DoubleSide });
        const cableMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
        const socketMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd });
        const socketHoleMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });

        window.changeWood = (target, type) => {
            const config = woodMaterials[type];
            if (config) {
                const material = (target === 'user') ? userWoodMaterial : backWoodMaterial;
                material.color.setHex(config.color);
                material.roughness = config.roughness;
            }
        };

        const deskGroup = new THREE.Group();
        scene.add(deskGroup);
        const surfaceGroup = new THREE.Group();
        deskGroup.add(surfaceGroup);
        const itemsGroup = new THREE.Group();
        surfaceGroup.add(itemsGroup);
        const skirtsGroup = new THREE.Group(); // Grupo para faldones dinámicos
        surfaceGroup.add(skirtsGroup);

        const deskWidth = 180, deskDepth = 80, deskHeight = 75, woodThick = 3.0, legThickness = 10;
        const innerGap = deskWidth - (legThickness * 2);
        const userPlankDepth = 55, backPlankDepth = 24, cableGapDepth = 1.0;
        const deskTopY = deskHeight;

        // --- Tapa Principal (con ranuras cortadas y corte 45° en borde trasero) ---
        const slotWidth = 1.5, slotLength = 5.5;
        const slotXOffset = 60; // distancia desde los bordes

        const userPlankShape = new THREE.Shape();
        userPlankShape.moveTo(-deskWidth/2, -userPlankDepth/2);
        userPlankShape.lineTo(deskWidth/2, -userPlankDepth/2);
        userPlankShape.lineTo(deskWidth/2, userPlankDepth/2);
        userPlankShape.lineTo(-deskWidth/2, userPlankDepth/2);
        userPlankShape.closePath();

        // Ranura izquierda (desplazada 10cm hacia faldón frontal)
        const hole1 = new THREE.Path();
        const slot1X = -deskWidth/2 + slotXOffset;
        const slotZOffset = -10; // desplazamiento hacia faldón frontal
        hole1.moveTo(slot1X - slotWidth/2, -slotLength/2 + slotZOffset);
        hole1.lineTo(slot1X + slotWidth/2, -slotLength/2 + slotZOffset);
        hole1.lineTo(slot1X + slotWidth/2, slotLength/2 + slotZOffset);
        hole1.lineTo(slot1X - slotWidth/2, slotLength/2 + slotZOffset);
        hole1.closePath();
        userPlankShape.holes.push(hole1);

        // Ranura derecha (desplazada 10cm hacia faldón frontal)
        const hole2 = new THREE.Path();
        const slot2X = deskWidth/2 - slotXOffset;
        hole2.moveTo(slot2X - slotWidth/2, -slotLength/2 + slotZOffset);
        hole2.lineTo(slot2X + slotWidth/2, -slotLength/2 + slotZOffset);
        hole2.lineTo(slot2X + slotWidth/2, slotLength/2 + slotZOffset);
        hole2.lineTo(slot2X - slotWidth/2, slotLength/2 + slotZOffset);
        hole2.closePath();
        userPlankShape.holes.push(hole2);

        const userPlankGeo = new THREE.ExtrudeGeometry(userPlankShape, { depth: woodThick, bevelEnabled: false });
        userPlankGeo.rotateX(-Math.PI/2);
        // Corte 45° en borde trasero (Z positivo, Y positivo)
        const posUser = userPlankGeo.attributes.position;
        for (let i = 0; i < posUser.count; i++) {
            const z = posUser.getZ(i);
            const y = posUser.getY(i);
            if (z > userPlankDepth/2 - 0.1 && y > 0) {
                posUser.setZ(i, z - woodThick);
            }
        }
        posUser.needsUpdate = true;
        userPlankGeo.computeVertexNormals();
        const userPlank = new THREE.Mesh(userPlankGeo, userWoodMaterial);
        userPlank.position.set(0, deskTopY - woodThick, -(deskDepth/2) + (userPlankDepth/2));
        userPlank.castShadow = true; userPlank.receiveShadow = true;
        surfaceGroup.add(userPlank);

        // --- Tapa Posterior (corte 45° paralelo a tapa grande) ---
        const backPlankGeo = new THREE.BoxGeometry(deskWidth, woodThick, backPlankDepth);
        const posBack = backPlankGeo.attributes.position;
        for (let i = 0; i < posBack.count; i++) {
            const z = posBack.getZ(i);
            const y = posBack.getY(i);
            if (z < 0 && y < 0) {
                posBack.setZ(i, z + woodThick);
            }
        }
        posBack.needsUpdate = true;
        backPlankGeo.computeVertexNormals();
        const backPlank = new THREE.Mesh(backPlankGeo, backWoodMaterial);
        backPlank.position.set(0, deskTopY - woodThick/2, (deskDepth/2) - (backPlankDepth/2));
        backPlank.castShadow = true; backPlank.receiveShadow = true;
        surfaceGroup.add(backPlank);

        // --- Estructura Metálica: Bandeja ---
        const gapZ = -(deskDepth/2) + userPlankDepth + (cableGapDepth/2);
        const trayProfile = new THREE.Shape();
        const th = 0.4, trayDepthVal = 16, highWall = 10, lowWall = 4;
        trayProfile.moveTo(-trayDepthVal/2, highWall); trayProfile.lineTo(-trayDepthVal/2, 0); trayProfile.lineTo(trayDepthVal/2, 0); trayProfile.lineTo(trayDepthVal/2, lowWall);
        trayProfile.lineTo(trayDepthVal/2 - th, lowWall); trayProfile.lineTo(trayDepthVal/2 - th, th); trayProfile.lineTo(-trayDepthVal/2 + th, th); trayProfile.lineTo(-trayDepthVal/2 + th, highWall);
        trayProfile.closePath();
        const trayGeo = new THREE.ExtrudeGeometry(trayProfile, { depth: innerGap, bevelEnabled: false });
        trayGeo.center();
        const tray = new THREE.Mesh(trayGeo, trayMaterial);
        tray.rotation.y = Math.PI/2;
        tray.position.set(0, deskTopY - woodThick - (highWall/2) - 0.2, gapZ);
        tray.castShadow = true; tray.receiveShadow = true;
        deskGroup.add(tray);

        // --- Enchufes ---
        function createSocketPair() {
            const group = new THREE.Group();
            const box = new THREE.Mesh(new THREE.BoxGeometry(12, 5, 2), socketMaterial);
            group.add(box);
            for(let i=0; i<2; i++){
                const xOff = (i === 0) ? -3 : 3;
                const hole = new THREE.Mesh(new THREE.CircleGeometry(1.2, 16), socketHoleMaterial);
                hole.position.set(xOff, 0, 1.05); group.add(hole);
            }
            group.rotation.x = -Math.PI / 2;
            return group;
        }
        const trayBottomY = deskTopY - woodThick - highWall + 1.2;
        const posLeft = -50, posCenter = 0, posRight = 50;
        [posLeft, posCenter, posRight].forEach(x => {
            const pair = createSocketPair(); pair.position.set(x, trayBottomY, gapZ); deskGroup.add(pair);
        });

        // --- Patas ---
        function createLeg() {
            const hLeg = deskHeight - woodThick;
            const s = new THREE.Shape();
            s.moveTo(-40, hLeg); s.lineTo(40, hLeg); s.lineTo(30, 0); s.lineTo(-30, 0); s.lineTo(-40, hLeg);
            const h = new THREE.Path();
            const topF = 10, sideF = 6, botF = 6;
            h.moveTo(-34, hLeg - topF); h.lineTo(-24, botF); h.lineTo(24, botF); h.lineTo(34, hLeg - topF); h.lineTo(-34, hLeg - topF);
            s.holes.push(h);
            const g = new THREE.ExtrudeGeometry(s, { depth: legThickness, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelSegments: 3 });
            g.center();
            const m = new THREE.Mesh(g, metalBlackMaterial); m.castShadow = true; return m;
        }
        const legOffset = (deskWidth / 2) - (legThickness / 2);
        const l1 = createLeg(); l1.rotation.y = Math.PI/2; l1.position.set(-legOffset, (deskHeight-woodThick)/2, 0); deskGroup.add(l1);
        const l2 = createLeg(); l2.rotation.y = Math.PI/2; l2.position.set(legOffset, (deskHeight-woodThick)/2, 0); deskGroup.add(l2);

        // --- Cableado ---
        const cableCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(posLeft - 10, trayBottomY - 0.5, gapZ - 2),
            new THREE.Vector3(posCenter, trayBottomY - 0.5, gapZ - 2),
            new THREE.Vector3(posRight, trayBottomY - 0.5, gapZ - 2),
            new THREE.Vector3(innerGap/2 - 2, trayBottomY - 0.5, gapZ - 2),
            new THREE.Vector3(legOffset, deskTopY - woodThick - 5, gapZ),
            new THREE.Vector3(legOffset, deskTopY - woodThick - 5, -35),
            new THREE.Vector3(legOffset, deskHeight/2, -35),
            new THREE.Vector3(legOffset, 0.4, -35),
            new THREE.Vector3(legOffset + 5, 0.4, -45),
            new THREE.Vector3(legOffset + 25, 0.4, -65)
        ]);
        const cableTube = new THREE.Mesh(new THREE.TubeGeometry(cableCurve, 100, 0.4, 8, false), cableMaterial);
        cableTube.castShadow = true; deskGroup.add(cableTube);

        // --- Faldones y Cotas Dinámicas ---
        const dimGroup = new THREE.Group();
        const dynamicDimGroup = new THREE.Group(); // Para cotas que cambian
        scene.add(dimGroup);
        scene.add(dynamicDimGroup);

        function addDim(s, e, t, o, container = dimGroup) {
            const p1 = new THREE.Vector3().copy(s).add(o), p2 = new THREE.Vector3().copy(e).add(o);
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1, p2]), new THREE.LineBasicMaterial({ color: 0xcc0000 }));
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 64; ctx.font = "Bold 35px Arial"; ctx.fillStyle = "#cc0000"; ctx.textAlign = "center"; ctx.fillText(t, 128, 45);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            sprite.scale.set(16, 4, 1); sprite.position.copy(new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5)); sprite.position.y += 2.5;
            container.add(new THREE.Group().add(line, sprite));
        }

        window.updateSkirts = () => {
            // Limpiar faldones anteriores
            while(skirtsGroup.children.length > 0) skirtsGroup.remove(skirtsGroup.children[0]);
            while(dynamicDimGroup.children.length > 0) dynamicDimGroup.remove(dynamicDimGroup.children[0]);

            const hFront = parseFloat(document.getElementById('hFrontSelector').value);
            const hBack = parseFloat(document.getElementById('hBackSelector').value);
            const tilt = Math.atan(10/75);

            // Faldón Usuario
            if (hFront > 0) {
                const fUserG = new THREE.Group();
                fUserG.position.set(0, 75, -40);
                fUserG.rotation.x = -tilt;
                const fUser = new THREE.Mesh(new THREE.BoxGeometry(deskWidth, hFront, woodThick), userWoodMaterial);
                fUser.position.set(0, -(hFront/2), -woodThick/2);
                fUserG.add(fUser);
                skirtsGroup.add(fUserG);
                addDim(new THREE.Vector3(0, 75 - hFront, -40), new THREE.Vector3(0, 75, -40), `${hFront} cm`, new THREE.Vector3(0, 0, -5), dynamicDimGroup);
            }

            // Faldón Trasero
            if (hBack > 0) {
                const fMonitorG = new THREE.Group();
                fMonitorG.position.set(0, 75, 40);
                fMonitorG.rotation.x = tilt;
                const fMonitor = new THREE.Mesh(new THREE.BoxGeometry(deskWidth, hBack, woodThick), backWoodMaterial);
                fMonitor.position.set(0, -(hBack/2), woodThick/2);
                fMonitorG.add(fMonitor);
                skirtsGroup.add(fMonitorG);
                addDim(new THREE.Vector3(0, 75 - hBack, 40), new THREE.Vector3(0, 75, 40), `${hBack} cm`, new THREE.Vector3(0, 0, 5), dynamicDimGroup);
            }

            dynamicDimGroup.visible = dimGroup.visible;
        };

        // Cotas estáticas
        addDim(new THREE.Vector3(-90, 75, -40), new THREE.Vector3(90, 75, -40), "180 cm", new THREE.Vector3(0, 15, 0));
        addDim(new THREE.Vector3(90, 75, -40), new THREE.Vector3(90, 75, 40), "80 cm", new THREE.Vector3(15, 0, 0));
        addDim(new THREE.Vector3(90, 0, 40), new THREE.Vector3(90, 75, 40), "75 cm", new THREE.Vector3(15, 0, 0));
        const dOffset = new THREE.Vector3(10, 5, 0);
        addDim(new THREE.Vector3(90, 75, -40), new THREE.Vector3(90, 75, 15), "55 cm", dOffset);
        addDim(new THREE.Vector3(90, 75, 15), new THREE.Vector3(90, 75, 16), "1 cm", dOffset);
        addDim(new THREE.Vector3(90, 75, 16), new THREE.Vector3(90, 75, 40), "24 cm", dOffset);
        addDim(new THREE.Vector3(-90, 72, -40), new THREE.Vector3(-90, 75, -40), "3 cm", new THREE.Vector3(-10, 0, 0));

        // Cotas de ranuras (junto a la ranura izquierda)
        // Tras rotación y posición: X=-30, Z=-12.5+10=-2.5
        const slotCZ = -2.5;
        const slotCX = -30;
        const slotTop = 75.5;
        // Largo de ranura (al lado)
        addDim(new THREE.Vector3(slotCX + 2, slotTop, slotCZ - 2.75), new THREE.Vector3(slotCX + 2, slotTop, slotCZ + 2.75), "5.5 cm", new THREE.Vector3(1, 0, 0));
        // Ancho de ranura (hacia faldón frontal)
        addDim(new THREE.Vector3(slotCX - 0.75, slotTop, slotCZ - 4), new THREE.Vector3(slotCX + 0.75, slotTop, slotCZ - 4), "1.5 cm", new THREE.Vector3(0, 0, -1));
        // Distancia desde borde frontal a ranura
        addDim(new THREE.Vector3(slotCX, slotTop, -40), new THREE.Vector3(slotCX, slotTop, slotCZ - 2.75), "34.75 cm", new THREE.Vector3(-3, 0, 0));
        // Distancia desde borde lateral izquierdo a ranura
        addDim(new THREE.Vector3(-90, slotTop, slotCZ), new THREE.Vector3(slotCX - 0.75, slotTop, slotCZ), "60 cm", new THREE.Vector3(0, 2, 0));

        dimGroup.visible = false;
        dynamicDimGroup.visible = false;

        window.toggleDimensions = () => {
            dimGroup.visible = document.getElementById('check-dims').checked;
            dynamicDimGroup.visible = dimGroup.visible;
        };
        window.toggleSurface = () => { surfaceGroup.visible = document.getElementById('check-surface').checked; };

        // --- Accesorios ---
        function createMacBook() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(34, 1, 24), silverMaterial);
            base.position.y = 0.501; group.add(base);
            const kb = new THREE.Mesh(new THREE.BoxGeometry(28, 0.1, 10), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            kb.position.set(0, 1.05, -2); group.add(kb);
            const lidPivot = new THREE.Group();
            lidPivot.position.set(0, 1, 12);
            const lid = new THREE.Mesh(new THREE.BoxGeometry(34, 0.6, 24), silverMaterial);
            lid.position.set(0, 0, -12); lidPivot.add(lid);
            const screen = new THREE.Mesh(new THREE.BoxGeometry(32, 22, 0.1), new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.1 }));
            screen.rotation.x = Math.PI / 2; screen.position.set(0, -0.35, -12); lidPivot.add(screen);
            lidPivot.rotation.x = Math.PI / 2.2; group.add(lidPivot);
            return group;
        }

        function createMonitor(withArm) {
            const g = new THREE.Group();
            const screen = new THREE.Mesh(new THREE.BoxGeometry(60, 35, 2), silverMaterial);
            const display = new THREE.Mesh(new THREE.BoxGeometry(58, 33, 0.2), new THREE.MeshStandardMaterial({ color: 0x050505 }));
            display.position.z = -1.1; screen.add(display);
            if (withArm) {
                const arm = new THREE.Group();
                const baseClamp = new THREE.Mesh(new THREE.BoxGeometry(8, 12, 8), metalBlackMaterial);
                baseClamp.position.set(0, -5, 4);
                const p1 = new THREE.Mesh(new THREE.BoxGeometry(4, 25, 4), metalBlackMaterial);
                p1.position.y = 12.5;
                const p2 = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 25), metalBlackMaterial);
                p2.position.set(0, 25, -12); arm.add(baseClamp, p1, p2);
                arm.position.set(0, 0, 35); screen.position.set(0, 25, 10); g.add(arm, screen);
            } else {
                const neck = new THREE.Mesh(new THREE.BoxGeometry(4, 20, 2), silverMaterial);
                neck.position.y = 10; screen.position.y = 25;
                g.add(new THREE.Mesh(new THREE.BoxGeometry(20, 1, 15), silverMaterial), neck, screen);
                g.position.z = 25;
            }
            return g;
        }

        function createChair() {
            const g = new THREE.Group();
            const baseCenter = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 2, 8), metalBlackMaterial);
            baseCenter.position.y = 5; g.add(baseCenter);
            for(let i=0; i<5; i++){
                const leg = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 25), metalBlackMaterial);
                leg.position.set(Math.sin(i*1.25)*12, 4, Math.cos(i*1.25)*12);
                leg.rotation.y = i*1.25; g.add(leg);
                const wheel = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), leatherMaterial);
                wheel.position.set(Math.sin(i*1.25)*25, 2, Math.cos(i*1.25)*25); g.add(wheel);
            }
            const pistonH = 26;
            const piston = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.2, pistonH, 16), silverMaterial);
            piston.position.y = 5 + (pistonH / 2); g.add(piston);
            const seatY = 5 + pistonH + 4;
            const seat = new THREE.Mesh(new THREE.BoxGeometry(45, 8, 45), leatherMaterial);
            seat.position.y = seatY; g.add(seat);
            const back = new THREE.Mesh(new THREE.BoxGeometry(45, 60, 8), leatherMaterial);
            back.position.set(0, seatY + 28, 22); back.rotation.x = -0.1; g.add(back);
            for(let i=0; i<2; i++){
                const side = i === 0 ? -25 : 25;
                const arm = new THREE.Mesh(new THREE.BoxGeometry(4, 15, 20), leatherMaterial);
                arm.position.set(side, seatY + 10, 0); g.add(arm);
            }
            g.traverse(n => { if(n.isMesh) { n.castShadow = true; n.receiveShadow = true; }});
            return g;
        }

        function createLamp() {
            const g = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(8, 8, 1, 32), metalBlackMaterial);
            const neck = new THREE.Mesh(new THREE.BoxGeometry(2, 40, 2), metalBlackMaterial);
            neck.position.set(0, 20, 0); neck.rotation.z = -0.2;
            const head = new THREE.Mesh(new THREE.BoxGeometry(25, 2, 5), metalBlackMaterial);
            head.position.set(-10, 40, 0); g.add(base, neck, head);
            return g;
        }

        window.updateItems = () => {
            while(itemsGroup.children.length > 0) itemsGroup.remove(itemsGroup.children[0]);
            if (document.getElementById('check-chair').checked) {
                const chair = createChair(); chair.position.set(0, 0, -85); chair.rotation.y = Math.PI; itemsGroup.add(chair);
            }
            if (document.getElementById('check-laptop').checked) {
                const laptop = createMacBook(); laptop.position.set(0, deskTopY, -15); itemsGroup.add(laptop);
            }
            if (document.getElementById('check-monitor').checked) {
                const mon = createMonitor(false); mon.position.set(0, deskTopY, 5); itemsGroup.add(mon);
            }
            if (document.getElementById('check-arm-monitor').checked) {
                const armMon = createMonitor(true); armMon.position.set(-55, deskTopY, 0); itemsGroup.add(armMon);
            }
            if (document.getElementById('check-lamp').checked) {
                const lamp = createLamp(); lamp.position.set(65, deskTopY, 15); itemsGroup.add(lamp);
            }
        };

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.ShadowMaterial({ opacity: 0.15 }));
        ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Inicialización
        updateSkirts();
        animate();
    </script>
</body>
</html>
