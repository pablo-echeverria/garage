<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escritorio Industrial 3D - Sistema El√©ctrico</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #333;
            pointer-events: none;
            z-index: 10;
        }
        #controls-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            z-index: 20;
            max-height: 90vh;
            overflow-y: auto;
            padding-right: 10px;
        }
        .control-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: auto;
            min-width: 220px;
            backdrop-filter: blur(5px);
        }
        h3 { margin: 0 0 10px 0; font-size: 14px; color: #444; font-weight: 700; border-bottom: 1px solid #eee; padding-bottom: 5px; }

        select, button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            outline: none;
            cursor: pointer;
            background: #f8f9fa;
            font-weight: 600;
            color: #333;
            transition: 0.2s;
        }
        button:hover, select:hover { background: #e9ecef; }

        .item-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
        }
        .item-toggle input { cursor: pointer; width: 18px; height: 18px; }

        .help-text { font-size: 11px; color: #666; margin-top: 5px; text-align: center; }
    </style>
</head>
<body>
    <div id="info">
        <h2>Visualizador de Escritorio Industrial</h2>
        <p>Cable por interior de pata, saliendo hacia el frente (lado silla)</p>
    </div>

    <div id="controls-ui">
        <div class="control-box">
            <h3>üñ•Ô∏è Accesorios</h3>
            <div class="item-toggle">
                <span>MacBook Pro</span>
                <input type="checkbox" id="check-laptop" onchange="updateItems()">
            </div>
            <div class="item-toggle">
                <span>Monitor (Base)</span>
                <input type="checkbox" id="check-monitor" onchange="updateItems()">
            </div>
            <div class="item-toggle">
                <span>Monitor (Brazo)</span>
                <input type="checkbox" id="check-arm-monitor" onchange="updateItems()">
            </div>
            <div class="item-toggle">
                <span>L√°mpara LED</span>
                <input type="checkbox" id="check-lamp" onchange="updateItems()">
            </div>
        </div>

        <div class="control-box">
            <h3>üé® Acabado</h3>
            <select id="woodSelector" onchange="changeWood(this.value)">
                <optgroup label="Maderas">
                    <option value="black">Negro Mate</option>
                    <option value="oak">Roble Claro</option>
                    <option value="walnut">Nogal Americano</option>
                    <option value="mahogany">Caoba Rojizo</option>
                    <option value="white">Blanco Minimalista</option>
                    <option value="grey">Gris Cemento</option>
                </optgroup>
                <optgroup label="Colores S√≥lidos">
                    <option value="solid_navy">Azul Marino</option>
                    <option value="solid_red">Rojo Vino</option>
                    <option value="solid_green">Verde Oliva</option>
                </optgroup>
            </select>
        </div>

        <div class="control-box">
            <button onclick="toggleDimensions()">Ocultar/Mostrar Medidas</button>
            <div class="help-text">
                üñ±Ô∏è Rotar | üñ±Ô∏è Mover | üñ±Ô∏è Zoom
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Escena B√°sica ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(-180, 160, -180);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI - 0.1;

        // Luces
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(-50, 150, -50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- Materiales ---
        const woodMaterials = {
            black: { color: 0x111111, roughness: 0.9 },
            oak: { color: 0xE0C9A6, roughness: 0.6 },
            walnut: { color: 0x5C4033, roughness: 0.7 },
            mahogany: { color: 0x420D09, roughness: 0.6 },
            white: { color: 0xFFFFFF, roughness: 0.4 },
            grey: { color: 0x555555, roughness: 0.8 },
            solid_navy: { color: 0x2c3e50, roughness: 0.5 },
            solid_red: { color: 0x922B21, roughness: 0.5 },
            solid_green: { color: 0x556b2f, roughness: 0.5 }
        };

        const woodMaterial = new THREE.MeshStandardMaterial({ color: woodMaterials.black.color, roughness: 0.9, side: THREE.DoubleSide });
        const metalBlackMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.5, metalness: 0.7, side: THREE.DoubleSide });
        const silverMaterial = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.3, metalness: 0.8 });
        const screenMaterial = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.1 });
        const cableMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });

        window.changeWood = (type) => {
            const s = woodMaterials[type];
            if (s) { woodMaterial.color.setHex(s.color); woodMaterial.roughness = s.roughness; }
        };

        const deskGroup = new THREE.Group();
        scene.add(deskGroup);

        const itemsGroup = new THREE.Group();
        deskGroup.add(itemsGroup);

        // --- Estructura del Escritorio ---
        const deskWidth = 180, deskDepth = 80, deskHeight = 75, woodThick = 3.0, legThickness = 10;
        const woodWidthTotal = deskWidth;
        const innerGap = deskWidth - (legThickness * 2);
        const deskTopY = deskHeight;

        const userPlankDepth = 55;
        const backPlankDepth = 24;
        const cableGapDepth = 1.0;

        // Tableros superiores
        const userPlank = new THREE.Mesh(new THREE.BoxGeometry(woodWidthTotal, woodThick, userPlankDepth), woodMaterial);
        userPlank.position.set(0, deskTopY - woodThick/2, -(deskDepth/2) + (userPlankDepth/2));
        userPlank.castShadow = true; userPlank.receiveShadow = true;
        deskGroup.add(userPlank);

        const backPlank = new THREE.Mesh(new THREE.BoxGeometry(woodWidthTotal, woodThick, backPlankDepth), woodMaterial);
        backPlank.position.set(0, deskTopY - woodThick/2, (deskDepth/2) - (backPlankDepth/2));
        backPlank.castShadow = true; backPlank.receiveShadow = true;
        deskGroup.add(backPlank);

        // Bandeja T√©cnica (Canaleta en U)
        const gapZ = -(deskDepth/2) + userPlankDepth + (cableGapDepth/2);
        const trayShape = new THREE.Shape();
        trayShape.moveTo(-7.5, 12); trayShape.lineTo(-7.5, 0); trayShape.lineTo(7.5, 0); trayShape.lineTo(7.5, 12);
        const trayInner = new THREE.Path();
        trayInner.moveTo(7, 12); trayInner.lineTo(7, 0.5); trayInner.lineTo(-7, 0.5); trayInner.lineTo(-7, 12);
        trayShape.holes.push(trayInner);
        const trayGeometry = new THREE.ExtrudeGeometry(trayShape, { depth: innerGap, bevelEnabled: false });
        trayGeometry.center();
        const tray = new THREE.Mesh(trayGeometry, metalBlackMaterial);
        tray.rotation.y = Math.PI/2;
        tray.position.set(0, deskTopY - woodThick - 6, gapZ);
        deskGroup.add(tray);

        // Patas trapezoidales
        function createLeg() {
            const hLeg = deskHeight - woodThick;
            const s = new THREE.Shape();
            s.moveTo(-40, hLeg); s.lineTo(40, hLeg); s.lineTo(30, 0); s.lineTo(-30, 0); s.lineTo(-40, hLeg);
            const h = new THREE.Path();
            const sideF = 6, topF = 10, botF = 6;
            h.moveTo(-34, hLeg - topF); h.lineTo(-24, botF); h.lineTo(24, botF); h.lineTo(34, hLeg - topF); h.lineTo(-34, hLeg - topF);
            s.holes.push(h);
            const g = new THREE.ExtrudeGeometry(s, { depth: legThickness, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelSegments: 3 });
            g.center();
            const m = new THREE.Mesh(g, metalBlackMaterial); m.castShadow = true; return m;
        }
        const legOffset = (deskWidth / 2) - (legThickness / 2);
        const l1 = createLeg(); l1.rotation.y = Math.PI/2; l1.position.set(-legOffset, (deskHeight-woodThick)/2, 0); deskGroup.add(l1);
        const l2 = createLeg(); l2.rotation.y = Math.PI/2; l2.position.set(legOffset, (deskHeight-woodThick)/2, 0); deskGroup.add(l2);

        // Faldones externos
        const tilt = Math.atan(10/75);
        const fMonitorG = new THREE.Group(); fMonitorG.position.set(0, 75, 40); fMonitorG.rotation.x = tilt;
        const fMonitor = new THREE.Mesh(new THREE.BoxGeometry(woodWidthTotal, 20, woodThick), woodMaterial);
        fMonitor.position.set(0, -10, woodThick/2); fMonitorG.add(fMonitor); deskGroup.add(fMonitorG);

        const fUserG = new THREE.Group(); fUserG.position.set(0, 75, -40); fUserG.rotation.x = -tilt;
        const fUser = new THREE.Mesh(new THREE.BoxGeometry(woodWidthTotal, 10, woodThick), woodMaterial);
        fUser.position.set(0, -5, -woodThick/2); fUserG.add(fUser); deskGroup.add(fUserG);

        // --- CABLEADO EL√âCTRICO ACTUALIZADO ---
        // 1. Salida de bandeja t√©cnica (Derecha)
        const trayRightEnd = new THREE.Vector3(innerGap/2 - 2, deskTopY - woodThick - 6, gapZ);

        // 2. Punto de entrada en la parte superior trasera de la pata derecha
        const legTopBackEntry = new THREE.Vector3(legOffset, deskTopY - woodThick - 5, gapZ);

        // 3. Viaje por el tubo superior hacia la solapa menor (hacia Z negativo)
        const legTopFrontCorner = new THREE.Vector3(legOffset, deskTopY - woodThick - 5, -35);

        // 4. Bajada por el perfil frontal de la pata hacia el suelo
        const legBottomFrontExit = new THREE.Vector3(legOffset, 0.5, -35);

        // 5. Salida hacia el frente (lado silla) para conectar al toma
        const socketPos = new THREE.Vector3(legOffset + 20, 0.5, -60);

        const cableCurve = new THREE.CatmullRomCurve3([
            trayRightEnd,
            new THREE.Vector3(trayRightEnd.x + 3, trayRightEnd.y, trayRightEnd.z), // Suavizado salida
            legTopBackEntry,
            legTopFrontCorner,
            new THREE.Vector3(legOffset, deskHeight/2, -35), // Punto intermedio bajada
            legBottomFrontExit,
            new THREE.Vector3(legOffset, 0.5, -45), // Curva en el piso hacia el frente
            socketPos
        ]);

        const cableTube = new THREE.Mesh(new THREE.TubeGeometry(cableCurve, 64, 0.4, 8, false), cableMaterial);
        cableTube.castShadow = true;
        deskGroup.add(cableTube);

        // Toma de corriente (simulada en el frente)
        const outlet = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 1), new THREE.MeshStandardMaterial({color: 0xdddddd}));
        outlet.position.set(socketPos.x, 4, socketPos.z - 1);
        outlet.rotation.y = Math.PI / 4;
        scene.add(outlet);

        // --- ACCESORIOS ---
        function createMacBook() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(34, 1, 24), silverMaterial);
            base.position.y = 0.501; group.add(base);
            const kb = new THREE.Mesh(new THREE.BoxGeometry(28, 0.1, 10), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            kb.position.set(0, 1.05, -2); group.add(kb);

            const lidPivot = new THREE.Group();
            lidPivot.position.set(0, 1, 12);
            const lid = new THREE.Mesh(new THREE.BoxGeometry(34, 0.6, 24), silverMaterial);
            lid.position.set(0, 0, -12); lidPivot.add(lid);
            const screen = new THREE.Mesh(new THREE.BoxGeometry(32, 22, 0.1), screenMaterial);
            screen.rotation.x = Math.PI / 2; screen.position.set(0, -0.35, -12); lidPivot.add(screen);
            lidPivot.rotation.x = Math.PI / 2.2; // Abierto hacia arriba
            group.add(lidPivot);
            return group;
        }

        function createMonitor(withArm) {
            const g = new THREE.Group();
            const screen = new THREE.Mesh(new THREE.BoxGeometry(60, 35, 2), silverMaterial);
            const display = new THREE.Mesh(new THREE.BoxGeometry(58, 33, 0.2), screenMaterial);
            display.position.z = -1.1; screen.add(display);
            if (withArm) {
                const arm = new THREE.Group();
                const baseClamp = new THREE.Mesh(new THREE.BoxGeometry(8, 12, 8), metalBlackMaterial);
                baseClamp.position.set(0, -5, 4);
                const p1 = new THREE.Mesh(new THREE.BoxGeometry(4, 25, 4), metalBlackMaterial);
                p1.position.y = 12.5;
                const p2 = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 25), metalBlackMaterial);
                p2.position.set(0, 25, -12);
                arm.add(baseClamp, p1, p2);
                arm.position.set(0, 0, deskDepth/2 - 5);
                screen.position.set(0, 25, deskDepth/2 - 30);
                g.add(arm, screen);
            } else {
                const neck = new THREE.Mesh(new THREE.BoxGeometry(4, 20, 2), silverMaterial);
                neck.position.y = 10; screen.position.y = 25;
                g.add(new THREE.Mesh(new THREE.BoxGeometry(20, 1, 15), silverMaterial), neck, screen);
                g.position.z = 25;
            }
            return g;
        }

        function createLamp() {
            const g = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(8, 8, 1, 32), metalBlackMaterial);
            const neck = new THREE.Mesh(new THREE.BoxGeometry(2, 40, 2), metalBlackMaterial);
            neck.position.set(0, 20, 0); neck.rotation.z = -0.2;
            const head = new THREE.Mesh(new THREE.BoxGeometry(25, 2, 5), metalBlackMaterial);
            head.position.set(-10, 40, 0); g.add(base, neck, head);
            return g;
        }

        window.updateItems = () => {
            while(itemsGroup.children.length > 0) itemsGroup.remove(itemsGroup.children[0]);
            if (document.getElementById('check-laptop').checked) {
                const laptop = createMacBook(); laptop.position.set(0, deskTopY, -15); itemsGroup.add(laptop);
            }
            if (document.getElementById('check-monitor').checked) {
                const mon = createMonitor(false); mon.position.set(0, deskTopY, 5); itemsGroup.add(mon);
            }
            if (document.getElementById('check-arm-monitor').checked) {
                const armMon = createMonitor(true); armMon.position.set(-55, deskTopY, 0); itemsGroup.add(armMon);
            }
            if (document.getElementById('check-lamp').checked) {
                const lamp = createLamp(); lamp.position.set(65, deskTopY, 15); itemsGroup.add(lamp);
            }
        };

        // Cotas
        const dimGroup = new THREE.Group();
        scene.add(dimGroup);
        function addDim(s, e, t, o) {
            const p1 = new THREE.Vector3().copy(s).add(o), p2 = new THREE.Vector3().copy(e).add(o);
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1, p2]), new THREE.LineBasicMaterial({ color: 0xcc0000 }));
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 64; ctx.font = "Bold 35px Arial"; ctx.fillStyle = "#cc0000"; ctx.textAlign = "center"; ctx.fillText(t, 128, 45);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            sprite.scale.set(20, 5, 1); sprite.position.copy(new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5)); sprite.position.y += 3;
            dimGroup.add(new THREE.Group().add(line, sprite));
        }
        addDim(new THREE.Vector3(-90, 75, -40), new THREE.Vector3(90, 75, -40), "180 cm", new THREE.Vector3(0, 15, 0));
        addDim(new THREE.Vector3(90, 75, -40), new THREE.Vector3(90, 75, 40), "80 cm", new THREE.Vector3(15, 0, 0));
        addDim(new THREE.Vector3(90, 0, 40), new THREE.Vector3(90, 75, 40), "75 cm", new THREE.Vector3(15, 0, 0));
        dimGroup.visible = false;
        window.toggleDimensions = () => { dimGroup.visible = !dimGroup.visible; };

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.ShadowMaterial({ opacity: 0.1 }));
        ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>
