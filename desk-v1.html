<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escritorio Industrial 3D - Setup Final</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        #controls-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none;
            z-index: 20;
            max-height: 90vh;
            overflow-y: auto;
            padding-right: 15px;
        }

        /* Estilo Transl√∫cido y Colapsable */
        .control-box {
            background: rgba(255, 255, 255, 0.65); /* Transl√∫cido */
            backdrop-filter: blur(10px); /* Desenfoque de fondo */
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            pointer-events: auto;
            min-width: 240px;
            transition: all 0.3s ease;
        }

        summary {
            padding: 12px 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 700;
            color: #222;
            list-style: none;
            outline: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        summary::-webkit-details-marker { display: none; }
        
        summary::after {
            content: '‚ñº';
            font-size: 10px;
            transition: transform 0.3s;
            opacity: 0.5;
        }

        details[open] summary::after {
            transform: rotate(180deg);
        }

        .content {
            padding: 0 15px 15px 15px;
            border-top: 1px solid rgba(0,0,0,0.05);
            padding-top: 12px;
        }

        select, button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: 8px;
            font-size: 13px;
            outline: none;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.8);
            font-weight: 600;
            color: #333;
            transition: background 0.2s;
        }
        button:hover { background: #fff; }
        
        .btn-toggle-view {
            background: #facc15; 
            color: #000;
            border: none;
        }
        .btn-toggle-view:hover { background: #eab308; }

        .item-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
            color: #444;
        }
        .item-toggle input { cursor: pointer; width: 18px; height: 18px; }

        .help-text { font-size: 11px; color: #666; margin-top: 5px; text-align: center; }
    </style>
</head>
<body>
    <div id="info"></div>
    
    <div id="controls-ui">
        <!-- Visualizaci√≥n -->
        <details class="control-box" open>
            <summary>üîç VISTA ESTRUCTURAL</summary>
            <div class="content">
                <button class="btn-toggle-view" onclick="toggleSurface()">Ocultar/Mostrar Tapas</button>
                <button onclick="toggleDimensions()">Ocultar/Mostrar Medidas</button>
            </div>
        </details>

        <!-- Panel de Accesorios -->
        <details class="control-box">
            <summary>üñ•Ô∏è ACCESORIOS</summary>
            <div class="content">
                <div class="item-toggle">
                    <span>MacBook Pro</span>
                    <input type="checkbox" id="check-laptop" onchange="updateItems()">
                </div>
                <div class="item-toggle">
                    <span>Monitor (Base)</span>
                    <input type="checkbox" id="check-monitor" onchange="updateItems()">
                </div>
                <div class="item-toggle">
                    <span>Monitor (Brazo)</span>
                    <input type="checkbox" id="check-arm-monitor" onchange="updateItems()">
                </div>
                <div class="item-toggle">
                    <span>L√°mpara LED</span>
                    <input type="checkbox" id="check-lamp" onchange="updateItems()">
                </div>
            </div>
        </details>

        <!-- Selector de Madera -->
        <details class="control-box" open>
            <summary>üé® ACABADO</summary>
            <div class="content">
                <select id="woodSelector" onchange="changeWood(this.value)">
                    <optgroup label="Maderas">
                        <option value="black">Negro Mate</option>
                        <option value="wenge">Wengue</option>
                        <option value="oak">Roble Claro</option>
                        <option value="walnut">Nogal Americano</option>
                        <option value="mahogany">Caoba Rojizo</option>
                        <option value="white">Blanco Minimalista</option>
                        <option value="grey">Gris Cemento</option>
                    </optgroup>
                    <optgroup label="Colores S√≥lidos">
                        <option value="solid_navy">Azul Marino</option>
                        <option value="solid_red">Rojo Vino</option>
                        <option value="solid_green">Verde Oliva</option>
                    </optgroup>
                </select>
                <div class="help-text">üñ±Ô∏è Rotar | üñ±Ô∏è Zoom</div>
            </div>
        </details>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Escena y C√°mara ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(-180, 110, -180); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI - 0.1;

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(-50, 150, -50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight);

        // --- Materiales ---
        const woodMaterials = {
            black: { color: 0x111111, roughness: 0.9 },
            wenge: { color: 0x221a15, roughness: 0.8 }, // Marr√≥n muy oscuro casi negro
            oak: { color: 0xE0C9A6, roughness: 0.6 },
            walnut: { color: 0x5C4033, roughness: 0.7 },
            mahogany: { color: 0x420D09, roughness: 0.6 },
            white: { color: 0xFFFFFF, roughness: 0.4 },
            grey: { color: 0x555555, roughness: 0.8 },
            solid_navy: { color: 0x2c3e50, roughness: 0.5 },
            solid_red: { color: 0x922B21, roughness: 0.5 },
            solid_green: { color: 0x556b2f, roughness: 0.5 }
        };

        const woodMaterial = new THREE.MeshStandardMaterial({ color: woodMaterials.black.color, roughness: 0.9, side: THREE.DoubleSide });
        const metalBlackMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.5, metalness: 0.7, side: THREE.DoubleSide });
        const silverMaterial = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.3, metalness: 0.8 });
        const screenMaterial = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.1 });
        const trayMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.5, metalness: 0.6, side: THREE.DoubleSide });
        const cableMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
        const socketMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd });
        const socketHoleMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });

        window.changeWood = (type) => {
            const s = woodMaterials[type];
            if (s) { woodMaterial.color.setHex(s.color); woodMaterial.roughness = s.roughness; }
        };

        const deskGroup = new THREE.Group();
        scene.add(deskGroup);

        const surfaceGroup = new THREE.Group();
        deskGroup.add(surfaceGroup);
        
        const itemsGroup = new THREE.Group();
        surfaceGroup.add(itemsGroup); 

        const deskWidth = 180, deskDepth = 80, deskHeight = 75, woodThick = 3.0, legThickness = 10;
        const innerGap = deskWidth - (legThickness * 2);
        const userPlankDepth = 55, backPlankDepth = 24, cableGapDepth = 1.0;
        const deskTopY = deskHeight;

        // --- Maderas ---
        const userPlank = new THREE.Mesh(new THREE.BoxGeometry(deskWidth, woodThick, userPlankDepth), woodMaterial);
        userPlank.position.set(0, deskTopY - woodThick/2, -(deskDepth/2) + (userPlankDepth/2));
        userPlank.castShadow = true; userPlank.receiveShadow = true;
        surfaceGroup.add(userPlank);

        const backPlank = new THREE.Mesh(new THREE.BoxGeometry(deskWidth, woodThick, backPlankDepth), woodMaterial);
        backPlank.position.set(0, deskTopY - woodThick/2, (deskDepth/2) - (backPlankDepth/2));
        backPlank.castShadow = true; backPlank.receiveShadow = true;
        surfaceGroup.add(backPlank);

        const tilt = Math.atan(10/75);
        const fMonitorG = new THREE.Group(); fMonitorG.position.set(0, 75, 40); fMonitorG.rotation.x = tilt; 
        const fMonitor = new THREE.Mesh(new THREE.BoxGeometry(deskWidth, 20, woodThick), woodMaterial);
        fMonitor.position.set(0, -10, woodThick/2); fMonitorG.add(fMonitor); 
        surfaceGroup.add(fMonitorG);

        const fUserG = new THREE.Group(); fUserG.position.set(0, 75, -40); fUserG.rotation.x = -tilt; 
        const fUser = new THREE.Mesh(new THREE.BoxGeometry(deskWidth, 10, woodThick), woodMaterial);
        fUser.position.set(0, -5, -woodThick/2); fUserG.add(fUser); 
        surfaceGroup.add(fUserG);

        // --- Bandeja T√©cnica en J ---
        const gapZ = -(deskDepth/2) + userPlankDepth + (cableGapDepth/2);
        const trayProfile = new THREE.Shape();
        const th = 0.4, trayDepthVal = 16, highWall = 10, lowWall = 4;   

        trayProfile.moveTo(-trayDepthVal/2, highWall);   
        trayProfile.lineTo(-trayDepthVal/2, 0);          
        trayProfile.lineTo(trayDepthVal/2, 0);           
        trayProfile.lineTo(trayDepthVal/2, lowWall);     
        trayProfile.lineTo(trayDepthVal/2 - th, lowWall); 
        trayProfile.lineTo(trayDepthVal/2 - th, th);      
        trayProfile.lineTo(-trayDepthVal/2 + th, th);     
        trayProfile.lineTo(-trayDepthVal/2 + th, highWall); 
        trayProfile.closePath(); 

        const trayGeo = new THREE.ExtrudeGeometry(trayProfile, { depth: innerGap, bevelEnabled: false });
        trayGeo.center();
        const tray = new THREE.Mesh(trayGeo, trayMaterial);
        tray.rotation.y = Math.PI/2; 
        tray.position.set(0, deskTopY - woodThick - (highWall/2), gapZ);
        tray.castShadow = true; tray.receiveShadow = true;
        deskGroup.add(tray);

        // --- Enchufes ---
        function createSocketPair() {
            const group = new THREE.Group();
            const box = new THREE.Mesh(new THREE.BoxGeometry(12, 5, 2), socketMaterial);
            group.add(box);
            for(let i=0; i<2; i++){
                const xOff = (i === 0) ? -3 : 3;
                const hole = new THREE.Mesh(new THREE.CircleGeometry(1.2, 16), socketHoleMaterial);
                hole.position.set(xOff, 0, 1.01);
                group.add(hole);
                const center = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.1), socketHoleMaterial);
                center.position.set(xOff, 0, 1.02);
                group.add(center);
            }
            group.rotation.x = -Math.PI / 2;
            return group;
        }

        const trayBottomY = deskTopY - woodThick - highWall + 1.0;
        const posLeft = -50, posCenter = 0, posRight = 50;
        [posLeft, posCenter, posRight].forEach(x => {
            const pair = createSocketPair();
            pair.position.set(x, trayBottomY, gapZ);
            deskGroup.add(pair);
        });

        // --- Patas ---
        function createLeg() {
            const hLeg = deskHeight - woodThick; 
            const s = new THREE.Shape();
            s.moveTo(-40, hLeg); s.lineTo(40, hLeg); s.lineTo(30, 0); s.lineTo(-30, 0); s.lineTo(-40, hLeg);
            const h = new THREE.Path();
            const topF = 10, sideF = 6, botF = 6; 
            h.moveTo(-34, hLeg - topF); h.lineTo(-24, botF); h.lineTo(24, botF); h.lineTo(34, hLeg - topF); h.lineTo(-34, hLeg - topF);
            s.holes.push(h);
            const g = new THREE.ExtrudeGeometry(s, { depth: legThickness, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelSegments: 3 });
            g.center();
            const m = new THREE.Mesh(g, metalBlackMaterial); m.castShadow = true; return m;
        }
        const legOffset = (deskWidth / 2) - (legThickness / 2); 
        const l1 = createLeg(); l1.rotation.y = Math.PI/2; l1.position.set(-legOffset, (deskHeight-woodThick)/2, 0); deskGroup.add(l1);
        const l2 = createLeg(); l2.rotation.y = Math.PI/2; l2.position.set(legOffset, (deskHeight-woodThick)/2, 0); deskGroup.add(l2);

        // --- Cableado ---
        const trayRightEnd = new THREE.Vector3(innerGap/2 - 2, trayBottomY, gapZ);
        const legTopBackEntry = new THREE.Vector3(legOffset, deskTopY - woodThick - 5, gapZ);
        const legTopFrontCorner = new THREE.Vector3(legOffset, deskTopY - woodThick - 5, -35);
        const legBottomFrontExit = new THREE.Vector3(legOffset, 0.4, -35); 
        const socketPos = new THREE.Vector3(legOffset + 25, 0.4, -65); 
        const cableCurve = new THREE.CatmullRomCurve3([trayRightEnd, legTopBackEntry, legTopFrontCorner, new THREE.Vector3(legOffset, deskHeight/2, -35), legBottomFrontExit, new THREE.Vector3(legOffset + 5, 0.4, -45), socketPos]);
        const cableTube = new THREE.Mesh(new THREE.TubeGeometry(cableCurve, 100, 0.4, 8, false), cableMaterial);
        cableTube.castShadow = true;
        deskGroup.add(cableTube);

        // --- UI ---
        window.toggleSurface = () => { surfaceGroup.visible = !surfaceGroup.visible; };

        // --- Accesorios ---
        function createMacBook() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(34, 1, 24), silverMaterial);
            base.position.y = 0.501; group.add(base);
            const kb = new THREE.Mesh(new THREE.BoxGeometry(28, 0.1, 10), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            kb.position.set(0, 1.05, -2); group.add(kb);
            const lidPivot = new THREE.Group();
            lidPivot.position.set(0, 1, 12); 
            const lid = new THREE.Mesh(new THREE.BoxGeometry(34, 0.6, 24), silverMaterial);
            lid.position.set(0, 0, -12); lidPivot.add(lid);
            const screen = new THREE.Mesh(new THREE.BoxGeometry(32, 22, 0.1), screenMaterial);
            screen.rotation.x = Math.PI / 2; screen.position.set(0, -0.35, -12); lidPivot.add(screen);
            lidPivot.rotation.x = Math.PI / 2.2;
            group.add(lidPivot);
            return group;
        }

        function createMonitor(withArm) {
            const g = new THREE.Group();
            const screen = new THREE.Mesh(new THREE.BoxGeometry(60, 35, 2), silverMaterial);
            const display = new THREE.Mesh(new THREE.BoxGeometry(58, 33, 0.2), screenMaterial);
            display.position.z = -1.1; screen.add(display);
            if (withArm) {
                const arm = new THREE.Group();
                const baseClamp = new THREE.Mesh(new THREE.BoxGeometry(8, 12, 8), metalBlackMaterial);
                baseClamp.position.set(0, -5, 4);
                const p1 = new THREE.Mesh(new THREE.BoxGeometry(4, 25, 4), metalBlackMaterial);
                p1.position.y = 12.5;
                const p2 = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 25), metalBlackMaterial);
                p2.position.set(0, 25, -12);
                arm.add(baseClamp, p1, p2);
                arm.position.set(0, 0, deskDepth/2 - 5);
                screen.position.set(0, 25, deskDepth/2 - 30);
                g.add(arm, screen);
            } else {
                g.add(new THREE.Mesh(new THREE.BoxGeometry(20, 1, 15), silverMaterial), new THREE.Mesh(new THREE.BoxGeometry(4, 20, 2), silverMaterial), screen);
                screen.position.y = 25; g.position.z = 25;
            }
            return g;
        }

        function createLamp() {
            const g = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(8, 8, 1, 32), metalBlackMaterial);
            const neck = new THREE.Mesh(new THREE.BoxGeometry(2, 40, 2), metalBlackMaterial);
            neck.position.set(0, 20, 0); neck.rotation.z = -0.2; 
            const head = new THREE.Mesh(new THREE.BoxGeometry(25, 2, 5), metalBlackMaterial);
            head.position.set(-10, 40, 0); g.add(base, neck, head);
            return g;
        }

        window.updateItems = () => {
            while(itemsGroup.children.length > 0) itemsGroup.remove(itemsGroup.children[0]);
            if (document.getElementById('check-laptop').checked) {
                const laptop = createMacBook(); laptop.position.set(0, deskTopY, -15); itemsGroup.add(laptop);
            }
            if (document.getElementById('check-monitor').checked) {
                const mon = createMonitor(false); mon.position.set(0, deskTopY, 5); itemsGroup.add(mon);
            }
            if (document.getElementById('check-arm-monitor').checked) {
                const armMon = createMonitor(true); armMon.position.set(-55, deskTopY, 0); itemsGroup.add(armMon);
            }
            if (document.getElementById('check-lamp').checked) {
                const lamp = createLamp(); lamp.position.set(65, deskTopY, 15); itemsGroup.add(lamp);
            }
        };

        const dimGroup = new THREE.Group();
        scene.add(dimGroup);
        function addDim(s, e, t, o) {
            const p1 = new THREE.Vector3().copy(s).add(o), p2 = new THREE.Vector3().copy(e).add(o);
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1, p2]), new THREE.LineBasicMaterial({ color: 0xcc0000 }));
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 64; ctx.font = "Bold 35px Arial"; ctx.fillStyle = "#cc0000"; ctx.textAlign = "center"; ctx.fillText(t, 128, 45);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            sprite.scale.set(20, 5, 1); sprite.position.copy(new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5)); sprite.position.y += 3;
            dimGroup.add(new THREE.Group().add(line, sprite));
        }
        addDim(new THREE.Vector3(-90, 75, -40), new THREE.Vector3(90, 75, -40), "180 cm", new THREE.Vector3(0, 15, 0));
        addDim(new THREE.Vector3(90, 75, -40), new THREE.Vector3(90, 75, 40), "80 cm", new THREE.Vector3(15, 0, 0));
        addDim(new THREE.Vector3(90, 0, 40), new THREE.Vector3(90, 75, 40), "75 cm", new THREE.Vector3(15, 0, 0));
        dimGroup.visible = false;
        window.toggleDimensions = () => { dimGroup.visible = !dimGroup.visible; };

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.ShadowMaterial({ opacity: 0.1 }));
        ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>
