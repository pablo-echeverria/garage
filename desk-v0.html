<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Escritorio Industrial 3D - Estructura Tubular</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #333;
            pointer-events: none;
            z-index: 10;
        }
        #controls-ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            z-index: 20;
        }
        .control-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            pointer-events: auto;
            min-width: 220px;
            backdrop-filter: blur(5px);
            transition: transform 0.2s;
        }
        h3 { margin: 0 0 10px 0; font-size: 14px; color: #444; font-weight: 700; }

        select, button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            outline: none;
            transition: all 0.2s;
            cursor: pointer;
            background: #f8f9fa;
            font-weight: 600;
            color: #333;
        }
        button:hover, select:hover { background: #e9ecef; }

        .help-text { font-size: 11px; color: #666; margin-top: 5px; text-align: center; }
    </style>
</head>
<body>
    <div id="info">
        <h2>Visualizador de Escritorio Industrial</h2>
        <p>Estructura: Ca√±os Rectangulares | 180cm x 80cm</p>
    </div>

    <div id="controls-ui">
        <!-- Selector Manual -->
        <div class="control-box">
            <h3>Acabado de Superficie</h3>
            <select id="woodSelector" onchange="changeWood(this.value)">
                <optgroup label="Maderas">
                    <option value="black">Negro Mate (Actual)</option>
                    <option value="oak">Roble Claro</option>
                    <option value="walnut">Nogal Americano</option>
                    <option value="mahogany">Caoba Rojizo</option>
                    <option value="white">Blanco Minimalista</option>
                    <option value="grey">Gris Cemento</option>
                </optgroup>
                <optgroup label="Colores S√≥lidos">
                    <option value="solid_navy">Azul Marino</option>
                    <option value="solid_red">Rojo Vino</option>
                    <option value="solid_green">Verde Oliva</option>
                    <option value="solid_mustard">Amarillo Mostaza</option>
                    <option value="solid_charcoal">Gris Carb√≥n</option>
                </optgroup>
            </select>
        </div>

        <!-- Bot√≥n Cotas -->
        <div class="control-box">
            <button onclick="toggleDimensions()">Ocultar/Mostrar Medidas</button>
            <div class="help-text">
                üñ±Ô∏è Click Izq: Rotar | üñ±Ô∏è Der: Mover | üñ±Ô∏è Rueda: Zoom
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(150, 120, 150);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI - 0.1;
        controls.minDistance = 50;
        controls.maxDistance = 400;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const fillLight = new THREE.PointLight(0xffffff, 0.7);
        fillLight.position.set(-50, 50, -50);
        scene.add(fillLight);

        const woodMaterials = {
            black: { color: 0x111111, roughness: 0.9, metalness: 0.0 },
            oak: { color: 0xE0C9A6, roughness: 0.6, metalness: 0.1 },
            walnut: { color: 0x5C4033, roughness: 0.7, metalness: 0.1 },
            mahogany: { color: 0x420D09, roughness: 0.6, metalness: 0.2 },
            white: { color: 0xFFFFFF, roughness: 0.4, metalness: 0.0 },
            grey: { color: 0x555555, roughness: 0.8, metalness: 0.1 },
            solid_navy: { color: 0x2c3e50, roughness: 0.5, metalness: 0.0 },
            solid_red: { color: 0x922B21, roughness: 0.5, metalness: 0.0 },
            solid_green: { color: 0x556b2f, roughness: 0.5, metalness: 0.0 },
            solid_mustard: { color: 0xd4ac0d, roughness: 0.5, metalness: 0.0 },
            solid_charcoal: { color: 0x333333, roughness: 0.6, metalness: 0.0 }
        };

        const woodMaterial = new THREE.MeshStandardMaterial({
            color: woodMaterials.black.color,
            roughness: woodMaterials.black.roughness,
            metalness: woodMaterials.black.metalness,
            side: THREE.DoubleSide
        });

        const metalBlackMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.5,
            metalness: 0.7,
            side: THREE.DoubleSide
        });

        window.changeWood = function(type) {
            const settings = woodMaterials[type];
            if (settings) {
                woodMaterial.color.setHex(settings.color);
                woodMaterial.roughness = settings.roughness;
                woodMaterial.metalness = settings.metalness;
                woodMaterial.needsUpdate = true;
            }
        };

        const deskGroup = new THREE.Group();
        scene.add(deskGroup);

        const deskWidth = 180;
        const deskDepth = 80;
        const deskHeight = 75;
        const woodThick = 2.0;
        const legThickness = 10;
        const woodWidth = deskWidth - (legThickness * 2);
        const tiltAngle = Math.atan(10 / 75);
        const cableGapDepth = 1.0;
        const backPlankDepth = 55;
        const frontPlankDepth = deskDepth - backPlankDepth - cableGapDepth;
        const frontApronHeight = 20;
        const backApronHeight = 10;
        const deskTopY = deskHeight;

        // 1. Tapa Superior Frontal
        const frontPlank = new THREE.Mesh(new THREE.BoxGeometry(woodWidth, woodThick, frontPlankDepth), woodMaterial);
        frontPlank.position.set(0, deskTopY - woodThick/2, (deskDepth/2) - (frontPlankDepth/2));
        frontPlank.castShadow = true;
        frontPlank.receiveShadow = true;
        deskGroup.add(frontPlank);

        // 2. Tapa Superior Posterior
        const backPlank = new THREE.Mesh(new THREE.BoxGeometry(woodWidth, woodThick, backPlankDepth), woodMaterial);
        backPlank.position.set(0, deskTopY - woodThick/2, -(deskDepth/2) + (backPlankDepth/2));
        backPlank.castShadow = true;
        backPlank.receiveShadow = true;
        deskGroup.add(backPlank);

        // --- COMPARTIMIENTO DE CABLES ACCESIBLE (Bandeja en "U") ---
        const gapZ = -(deskDepth/2) + backPlankDepth + (cableGapDepth/2);
        const compHeight = 12;
        const compDepth = 15;
        const trayThick = 0.5;

        // Crear perfil en U para la bandeja
        const trayShape = new THREE.Shape();
        // Empezar en la parte superior trasera de la bandeja
        trayShape.moveTo(-compDepth/2, compHeight);
        trayShape.lineTo(-compDepth/2, 0); // Bajar
        trayShape.lineTo(compDepth/2, 0);  // Ir al frente
        trayShape.lineTo(compDepth/2, compHeight); // Subir

        // El perfil interior para darle grosor (vaciado)
        const trayInnerPath = new THREE.Path();
        trayInnerPath.moveTo(compDepth/2 - trayThick, compHeight);
        trayInnerPath.lineTo(compDepth/2 - trayThick, trayThick);
        trayInnerPath.lineTo(-compDepth/2 + trayThick, trayThick);
        trayInnerPath.lineTo(-compDepth/2 + trayThick, compHeight);
        trayShape.holes.push(trayInnerPath);

        const trayGeo = new THREE.ExtrudeGeometry(trayShape, {
            depth: woodWidth,
            bevelEnabled: false
        });
        trayGeo.center();
        const compartment = new THREE.Mesh(trayGeo, metalBlackMaterial);

        // Rotar para que la "U" quede hacia arriba y se extienda a lo largo
        compartment.rotation.y = Math.PI / 2;
        compartment.position.set(0, deskTopY - woodThick - (compHeight/2), gapZ);
        compartment.castShadow = true;
        compartment.receiveShadow = true;
        deskGroup.add(compartment);

        // --- CABLE DE ALIMENTACI√ìN ---
        const cableMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.7 });
        const trayExitPoint = new THREE.Vector3((woodWidth/2) - 2, deskTopY - woodThick - (compHeight/2), gapZ);
        const legInnerX = (deskWidth/2) - legThickness;
        const legEntryPoint = new THREE.Vector3(legInnerX + 0.5, deskTopY - 5, 0);

        const curveIn = new THREE.CatmullRomCurve3([
            trayExitPoint,
            new THREE.Vector3(trayExitPoint.x + 5, trayExitPoint.y, trayExitPoint.z),
            new THREE.Vector3(legEntryPoint.x - 5, legEntryPoint.y, legEntryPoint.z),
            legEntryPoint
        ]);
        deskGroup.add(new THREE.Mesh(new THREE.TubeGeometry(curveIn, 12, 0.4, 8, false), cableMat));

        const legExitPoint = new THREE.Vector3(deskWidth/2, 0.5, 0);
        const socketPoint = new THREE.Vector3((deskWidth/2) + 30, 0.5, 20);
        const curveOut = new THREE.CatmullRomCurve3([
            legExitPoint,
            new THREE.Vector3(legExitPoint.x + 5, 0.5, 0),
            new THREE.Vector3(legExitPoint.x + 15, 0.5, 5),
            socketPoint
        ]);
        deskGroup.add(new THREE.Mesh(new THREE.TubeGeometry(curveOut, 20, 0.4, 8, false), cableMat));

        const plug = new THREE.Mesh(new THREE.BoxGeometry(5, 3, 3), new THREE.MeshStandardMaterial({ color: 0x333333 }));
        plug.position.copy(socketPoint);
        plug.lookAt(legExitPoint);
        deskGroup.add(plug);

        // 3. Fald√≥n Frontal Inclinado
        const frontApronGroup = new THREE.Group();
        frontApronGroup.position.set(0, deskTopY, deskDepth/2);
        frontApronGroup.rotation.x = tiltAngle;
        const frontApron = new THREE.Mesh(new THREE.BoxGeometry(woodWidth, frontApronHeight, woodThick), woodMaterial);
        frontApron.position.set(0, -frontApronHeight/2, -woodThick/2);
        frontApron.castShadow = true;
        frontApronGroup.add(frontApron);
        deskGroup.add(frontApronGroup);

        // 4. Fald√≥n Posterior Inclinado
        const backApronGroup = new THREE.Group();
        backApronGroup.position.set(0, deskTopY, -deskDepth/2);
        backApronGroup.rotation.x = -tiltAngle;
        const backApron = new THREE.Mesh(new THREE.BoxGeometry(woodWidth, backApronHeight, woodThick), woodMaterial);
        backApron.position.set(0, -backApronHeight/2, woodThick/2);
        backApron.castShadow = true;
        backApronGroup.add(backApron);
        deskGroup.add(backApronGroup);

        // Patas
        function createLeg() {
            const legShape = new THREE.Shape();
            const topW = deskDepth, botW = deskDepth - 20, height = deskTopY;
            legShape.moveTo(-topW/2, height); legShape.lineTo(topW/2, height); legShape.lineTo(botW/2, 0); legShape.lineTo(-botW/2, 0); legShape.lineTo(-topW/2, height);
            const hole = new THREE.Path();
            const sideFrameThick = 6, topFrameThick = 12.5, bottomFrameThick = 6;
            hole.moveTo(-(topW/2 - sideFrameThick), height - topFrameThick); hole.lineTo(-(botW/2 - sideFrameThick), bottomFrameThick); hole.lineTo((botW/2 - sideFrameThick), bottomFrameThick); hole.lineTo((topW/2 - sideFrameThick), height - topFrameThick); hole.lineTo(-(topW/2 - sideFrameThick), height - topFrameThick);
            legShape.holes.push(hole);
            const geometry = new THREE.ExtrudeGeometry(legShape, { steps: 2, depth: legThickness, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelSegments: 3 });
            geometry.center();
            const mesh = new THREE.Mesh(geometry, metalBlackMaterial);
            mesh.castShadow = true;
            return mesh;
        }

        const legOffset = (deskWidth / 2) - (legThickness / 2);
        const legLeft = createLeg(); legLeft.rotation.y = Math.PI / 2; legLeft.position.set(-legOffset, deskHeight/2, 0); deskGroup.add(legLeft);
        const legRight = createLeg(); legRight.rotation.y = Math.PI / 2; legRight.position.set(legOffset, deskHeight/2, 0); deskGroup.add(legRight);

        // Suelo
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.ShadowMaterial({ opacity: 0.1 }));
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Cotas
        const dimensionsGroup = new THREE.Group();
        scene.add(dimensionsGroup);
        function createTextSprite(message) {
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 128; ctx.font = "Bold 40px Arial"; ctx.fillStyle = "#cc0000"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(message, 128, 64);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            sprite.scale.set(20, 10, 1); return sprite;
        }
        function createDim(start, end, text, offset) {
            const p1 = new THREE.Vector3().copy(start).add(offset), p2 = new THREE.Vector3().copy(end).add(offset);
            const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1, p2]), new THREE.LineBasicMaterial({ color: 0xcc0000 }));
            const sprite = createTextSprite(text); sprite.position.copy(new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5)); sprite.position.y += 2;
            const g = new THREE.Group(); g.add(line, sprite); dimensionsGroup.add(g);
        }

        createDim(new THREE.Vector3(-90, 75, -40), new THREE.Vector3(90, 75, -40), "180 cm", new THREE.Vector3(0, 15, 0));
        createDim(new THREE.Vector3(90, 75, -40), new THREE.Vector3(90, 75, 40), "80 cm", new THREE.Vector3(15, 0, 0));
        createDim(new THREE.Vector3(90, 0, 40), new THREE.Vector3(90, 75, 40), "75 cm", new THREE.Vector3(15, 0, 0));

        window.toggleDimensions = function() { dimensionsGroup.visible = !dimensionsGroup.visible; };

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>
